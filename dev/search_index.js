var documenterSearchIndex = {"docs":
[{"location":"use/atomic/#Mathematical-Definitions","page":"Atomic Models","title":"Mathematical Definitions","text":"","category":"section"},{"location":"use/atomic/","page":"Atomic Models","title":"Atomic Models","text":"For the atomic model, G(u) is defined as","category":"page"},{"location":"use/atomic/","page":"Atomic Models","title":"Atomic Models","text":"G(hkl) = sum_j e^-i (x_j (h+G_h) + y_j (k+G_k) + z_j (l+G_l)) ","category":"page"},{"location":"use/atomic/","page":"Atomic Models","title":"Atomic Models","text":"where x_j y_j z_j are atom positions and hkl represent a distance away from some scattering vector G_h G_k G_l in reciprocal space. It is important that the hkl value are integers and that they range from -fracn2 to fracn2-1, so both real space and reciprocal space positions must be scaled. The x_jy_jz_j positions should be shifted to lie between 0 to 1 and should be multiplied by 2pi to capture the missing 2 pi scaling in the Fourier transform exponent.","category":"page"},{"location":"use/atomic/#Usage","page":"Atomic Models","title":"Usage","text":"","category":"section"},{"location":"use/atomic/","page":"Atomic Models","title":"Atomic Models","text":"Calculating the loss function and its derivative for the atomic model is done in three steps. First, the BcdiCore.AtomicState struct is created. Then, the atom positions are set by calling BcdiCore.setpts!. Finally, the loss function is calculated with BcdiCore.loss.","category":"page"},{"location":"use/atomic/","page":"Atomic Models","title":"Atomic Models","text":"state = AtomicState(lossType, scale, intens, G, h, k, l)\nsetpts!(state, x, y, z, getDeriv)\nlossVal = loss(state, getDeriv, getLoss)","category":"page"},{"location":"use/atomic/","page":"Atomic Models","title":"Atomic Models","text":"If the derivative is requested with the getDeriv variable, the results are stored in state.xDeriv,  state.yDeriv, and state.zDeriv.","category":"page"},{"location":"use/multi/#Mathematical-Definitions","page":"Multiscale Modes","title":"Mathematical Definitions","text":"","category":"section"},{"location":"use/multi/","page":"Multiscale Modes","title":"Multiscale Modes","text":"The multiscale model is a combination of an atomic scale and a mesoscale model. In this case,  G(hkl) is defined as","category":"page"},{"location":"use/multi/","page":"Multiscale Modes","title":"Multiscale Modes","text":"G(hkl) = G_a(hkl) + G_m(hkl)","category":"page"},{"location":"use/multi/","page":"Multiscale Modes","title":"Multiscale Modes","text":"where a signifies the atomic model and m signifies the mesoscale model.","category":"page"},{"location":"use/multi/#Usage","page":"Multiscale Modes","title":"Usage","text":"","category":"section"},{"location":"use/multi/","page":"Multiscale Modes","title":"Multiscale Modes","text":"Calculating the loss function and its derivative for the mesoscale model is done in three steps. First, the BcdiCore.MultiState struct is created. Then, the atom positions are set by calling BcdiCore.setpts!. Finally, the loss function is calculated with BcdiCore.loss.","category":"page"},{"location":"use/multi/","page":"Multiscale Modes","title":"Multiscale Modes","text":"state = MultiState(lossType, scale, intens, G, h, k, l)\nsetpts!(state, x, y, z, mx, my, mz, rho, ux, uy, uz, getDeriv)\nlossVal = loss(state, getDeriv, getLoss)","category":"page"},{"location":"use/multi/","page":"Multiscale Modes","title":"Multiscale Modes","text":"Here x, y, z are atomic positions and mx, my, mz are the real space locations of the mesoscale model.","category":"page"},{"location":"use/multi/","page":"Multiscale Modes","title":"Multiscale Modes","text":"If the derivative is requested with the getDeriv variable, the results are stored in state.xDeriv,  state.yDeriv, and state.zDeriv, state.rhoDeriv, state.uxDeriv,  state.uyDeriv, and state.uzDeriv.","category":"page"},{"location":"use/meso/#Mathematical-Definitions","page":"Mesoscale Models","title":"Mathematical Definitions","text":"","category":"section"},{"location":"use/meso/","page":"Mesoscale Models","title":"Mesoscale Models","text":"Similar to the atomic model, G(u) is initially defined as","category":"page"},{"location":"use/meso/","page":"Mesoscale Models","title":"Mesoscale Models","text":"G(hkl) = sum_j e^-i (x_j (h+G_h) + y_j (k+G_k) + z_j (l+G_l)) ","category":"page"},{"location":"use/meso/","page":"Mesoscale Models","title":"Mesoscale Models","text":"where x_j y_j z_j are atom positions and hkl represent a distance away from some scattering vector G_h G_k G_l in reciprocal space. However, x_j y_j z_j can be thought of as an addition of lattice spacings and displacement vectors, i.e.  x_j+ux_j y_j+uy_j z_j+uz_j. Then, if G_hG_kG_l are reciprocal lattice vectors, we find that x cdot G is an integer multiple of 2pi, so it does not affect the simulated electric field. We are then left with","category":"page"},{"location":"use/meso/","page":"Mesoscale Models","title":"Mesoscale Models","text":"G(hkl) = sum_j e^-i (x_j G_h + y_j G_k + uz_j G_l) e^-i (ux_j (h+G_h) + uy_j (k+G_k) + uz_j (l+G_l)) ","category":"page"},{"location":"use/meso/","page":"Mesoscale Models","title":"Mesoscale Models","text":"Coarse graining to get a mesoscale model, we get","category":"page"},{"location":"use/meso/","page":"Mesoscale Models","title":"Mesoscale Models","text":"G(hkl) = sum_j rho_j e^-i (x_j h + y_j k + uz_j l) e^-i (ux_j (h+G_h) + uy_j (k+G_k) + uz_j (l+G_l)) ","category":"page"},{"location":"use/meso/","page":"Mesoscale Models","title":"Mesoscale Models","text":"Again, it is important that the hkl value are integers and that they range from -fracn2 to fracn2-1, so both real space and reciprocal space positions must be scaled. The x_jy_jz_j positions should be shifted to lie between 0 to 1 and should be multiplied by 2pi to capture the missing 2 pi scaling in the Fourier transform exponent.","category":"page"},{"location":"use/meso/#Usage","page":"Mesoscale Models","title":"Usage","text":"","category":"section"},{"location":"use/meso/","page":"Mesoscale Models","title":"Mesoscale Models","text":"Calculating the loss function and its derivative for the mesoscale model is done in three steps. First, the BcdiCore.MesoState struct is created. Then, the atom positions are set by calling BcdiCore.setpts!. Finally, the loss function is calculated with BcdiCore.loss.","category":"page"},{"location":"use/meso/","page":"Mesoscale Models","title":"Mesoscale Models","text":"state = MesoState(lossType, scale, intens, G, h, k, l)\nsetpts!(state, x, y, z, rho, ux, uy, uz, getDeriv)\nlossVal = loss(state, getDeriv, getLoss)","category":"page"},{"location":"use/meso/","page":"Mesoscale Models","title":"Mesoscale Models","text":"If the derivative is requested with the getDeriv variable, the results are stored in state.rhoDeriv, state.uxDeriv,  state.uyDeriv, and state.uzDeriv.","category":"page"},{"location":"use/trad/#Mathematical-Definitions","page":"Traditional Models","title":"Mathematical Definitions","text":"","category":"section"},{"location":"use/trad/","page":"Traditional Models","title":"Traditional Models","text":"Similar to the mesoscale model, G(u) is initially defined as","category":"page"},{"location":"use/trad/","page":"Traditional Models","title":"Traditional Models","text":"G(hkl) = sum_j rho_j e^-i (x_j h + y_j k + uz_j l) e^-i (ux_j (h+G_h) + uy_j (k+G_k) + uz_j (l+G_l)) ","category":"page"},{"location":"use/trad/","page":"Traditional Models","title":"Traditional Models","text":"where x_j y_j z_j are real space positions, ux_j uy_j uz_j are diplacement vectors, and hkl represent a distance away from some scattering vector G_h G_k G_l in reciprocal space. However, we assume that, because the distance from the scattering vector and the displacement vectors are small, u cdot h is negligible. So we are left with","category":"page"},{"location":"use/trad/","page":"Traditional Models","title":"Traditional Models","text":"G(hkl) = sum_j rho_j e^-i (x_j h + y_j k + uz_j l) e^-i (ux_j G_h + uy_j G_k + uz_j G_l) ","category":"page"},{"location":"use/trad/","page":"Traditional Models","title":"Traditional Models","text":"Then, we combine the entire rho_j e^-i (ux_j G_h + uy_j G_k + uz_j G_l) quantity as one variable and get","category":"page"},{"location":"use/trad/","page":"Traditional Models","title":"Traditional Models","text":"G(hkl) = sum_j psi_j e^-i (x_j h + y_j k + uz_j l) ","category":"page"},{"location":"use/trad/","page":"Traditional Models","title":"Traditional Models","text":"In this case, this is an ordinary Fourier transform, so we put the factor of 2pi back into G(hkl) to get","category":"page"},{"location":"use/trad/","page":"Traditional Models","title":"Traditional Models","text":"G(hkl) = sum_j psi_j e^-2 pi i (x_j h + y_j k + uz_j l) ","category":"page"},{"location":"use/trad/#Usage","page":"Traditional Models","title":"Usage","text":"","category":"section"},{"location":"use/trad/","page":"Traditional Models","title":"Traditional Models","text":"Calculating the loss function and its derivative for the traditional model is done in two steps. First, the BcdiCore.TradState struct is created. Then, the loss function is calculated with BcdiCore.loss.","category":"page"},{"location":"use/trad/","page":"Traditional Models","title":"Traditional Models","text":"state = TradState(losstype, scale, intens, realSpace)\nlossVal = loss(state, getDeriv, getLoss)","category":"page"},{"location":"use/trad/","page":"Traditional Models","title":"Traditional Models","text":"If the derivative is requested with the getDeriv variable, the result us stored in state.deriv.","category":"page"},{"location":"#BcdiCore.jl-Documentation","page":"Main","title":"BcdiCore.jl Documentation","text":"","category":"section"},{"location":"#About","page":"Main","title":"About","text":"","category":"section"},{"location":"","page":"Main","title":"Main","text":"Bragg Coherent Diffraction Imaging (BCDI) Core implements some of the core functionality used for future projects BcdiAtomic.jl (an atomic scale BCDI solver), BcdiMeso.jl (a mesoscale BCDI Solver), BcdiMulti.jl (a multiscale BCDI solver), and BcdiTrad.jl (a BCDI solver using projection algorithms). BcdiCore.jl implements the loss functions and derivatives of loss functions used in these packages.","category":"page"},{"location":"","page":"Main","title":"Main","text":"While this package is marked as BCDI specific, the methods are more general and can be used in many phase retrieval problems. In the future, this package may be incorporated into a more general phase retrieval core package.","category":"page"},{"location":"","page":"Main","title":"Main","text":"Currently, this entire package must be run with access to GPUs. This may change in the future (especially if Issues requesting it are opened), but for our research group, using GPUs is a necessity.","category":"page"},{"location":"#Installation","page":"Main","title":"Installation","text":"","category":"section"},{"location":"","page":"Main","title":"Main","text":"Currently, BcdiCore.jl is not registered in the Julia general registry. BcdiCore.jl can be installed by running in the REPL package manager (]):","category":"page"},{"location":"","page":"Main","title":"Main","text":"add git@github.com:byu-cig/BcdiCore.jl.git","category":"page"},{"location":"use/overview/","page":"Overview","title":"Overview","text":"In general, BcdiCore.jl will be called by developers of phase retrieval codes, not end users. BcdiCore.jl implements loss functions and derivatives of loss functions for atomic models, mesoscale models, multiscale models, and traditional projection-based methods.","category":"page"},{"location":"use/overview/#Available-loss-functions","page":"Overview","title":"Available loss functions","text":"","category":"section"},{"location":"use/overview/","page":"Overview","title":"Overview","text":"Currently, BcdiCore.jl implements two types of losses, the average L_2 norm and the average log-likelihood. ","category":"page"},{"location":"use/overview/","page":"Overview","title":"Overview","text":"Explicitly, the average L_2 loss is defined as","category":"page"},{"location":"use/overview/","page":"Overview","title":"Overview","text":"L_2 = frac1N sum_u left( lvert G(u) rvert - lvert F(u) rvert right)^2","category":"page"},{"location":"use/overview/","page":"Overview","title":"Overview","text":"where G(u) is the simulated electric field, lvert F(u) rvert^2 is the measured intensity at a point u in reciprocal space, and N is the total number of meaurement points.","category":"page"},{"location":"use/overview/","page":"Overview","title":"Overview","text":"The average log-likelihood (for the Poisson distribution) is defined as","category":"page"},{"location":"use/overview/","page":"Overview","title":"Overview","text":"ell = frac1N sum_u lvert G(u) rvert^2 - lvert F(u) rvert^2 lnleft(lvert G(u) rvert^2 right)","category":"page"}]
}
